const precacheConfig = [['/index.html', '128902e350a08e41e5d89078761d17e5'], ['/static/css/main.e5b20a98.css', 'ece8f4ecc301fd29e0181d6e3aec7f61'], ['/static/js/main.8c46d382.js', '73af90ed61bd76675235b7cf796f5e4d'], ['/static/media/flags.9c74e172.png', '9c74e172f87984c48ddf5c8108cabe67'], ['/static/media/icons.674f50d2.eot', '674f50d287a8c48dc19ba404d20fe713'], ['/static/media/icons.912ec66d.svg', '912ec66d7572ff821749319396470bde'], ['/static/media/icons.af7ae505.woff2', 'af7ae505a9eed503f8b8e6982036873e'], ['/static/media/icons.b06871f2.ttf', 'b06871f281fee6b241d60582ae9369b9'], ['/static/media/icons.fee66e71.woff', 'fee66e712a8a08eef5805a46892932ad']]; const cacheName = `sw-precache-v3-sw-precache-webpack-plugin-${self.registration ? self.registration.scope : ''}`; const ignoreUrlParametersMatching = [/^utm_/]; const addDirectoryIndex = function (e, t) { const n = new URL(e); return n.pathname.slice(-1) === '/' && (n.pathname += t), n.toString(); }; const cleanResponse = function (e) { if (!e.redirected) return Promise.resolve(e); return ('body' in e ? Promise.resolve(e.body) : e.blob()).then(t => new Response(t, { headers: e.headers, status: e.status, statusText: e.statusText })); }; const createCacheKey = function (e, t, n, r) { const a = new URL(e); return r && a.pathname.match(r) || (a.search += `${(a.search ? '&' : '') + encodeURIComponent(t)}=${encodeURIComponent(n)}`), a.toString(); }; const isPathWhitelisted = function (e, t) { if (e.length === 0) return !0; const n = new URL(t).pathname; return e.some(e => n.match(e)); }; const stripIgnoredUrlParameters = function (e, t) {
  const n = new URL(e); return n.hash = '', n.search = n.search.slice(1).split('&').map(e => e.split('=')).filter(e => t.every(t => !t.test(e[0])))
    .map(e => e.join('='))
    .join('&'), n.toString();
}; const hashParamName = '_sw-precache'; const urlsToCacheKeys = new Map(precacheConfig.map((e) => { const t = e[0]; const n = e[1]; const r = new URL(t, self.location); const a = createCacheKey(r, hashParamName, n, /\.\w{8}\./); return [r.toString(), a]; })); function setOfCachedUrls(e) { return e.keys().then(e => e.map(e => e.url)).then(e => new Set(e)); }self.addEventListener('install', (e) => { e.waitUntil(caches.open(cacheName).then(e => setOfCachedUrls(e).then(t => Promise.all(Array.from(urlsToCacheKeys.values()).map((n) => { if (!t.has(n)) { const r = new Request(n, { credentials: 'same-origin' }); return fetch(r).then((t) => { if (!t.ok) throw new Error(`Request for ${n} returned a response with status ${t.status}`); return cleanResponse(t).then(t => e.put(n, t)); }); } })))).then(() => self.skipWaiting())); }), self.addEventListener('activate', (e) => { const t = new Set(urlsToCacheKeys.values()); e.waitUntil(caches.open(cacheName).then(e => e.keys().then(n => Promise.all(n.map((n) => { if (!t.has(n.url)) return e.delete(n); })))).then(() => self.clients.claim())); }), self.addEventListener('fetch', (e) => { if (e.request.method === 'GET') { let t; let n = stripIgnoredUrlParameters(e.request.url, ignoreUrlParametersMatching); const r = 'index.html'; (t = urlsToCacheKeys.has(n)) || (n = addDirectoryIndex(n, r), t = urlsToCacheKeys.has(n)); const a = '/index.html'; !t && e.request.mode === 'navigate' && isPathWhitelisted(['^(?!\\/__).*'], e.request.url) && (n = new URL(a, self.location).toString(), t = urlsToCacheKeys.has(n)), t && e.respondWith(caches.open(cacheName).then(e => e.match(urlsToCacheKeys.get(n)).then((e) => { if (e) return e; throw Error('The cached response that was expected is missing.'); })).catch(t => console.warn('Couldn\'t serve response for "%s" from cache: %O', e.request.url, t), fetch(e.request))); } });
